//patch to the wasm api.
//I should probably turn it into my own branche eventually and maybe even do some PR

/*
regular unwrap :
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os {
code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:4:49

regular expect :
thread 'main' panicked at 'hello.txt should be included in this project: Os {
code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:5:10

common prefix : "thread 'main' panicked at "
don't touch or do anything, the corresponding info will be sent by throw_str

Prefix error string:
'called `Result::unwrap()` on an `Err` value'   //generic message generated by unwrap
'hello.txt should be included in this project'  //custom message provided by user.

error string : ': Os {
code: 2, kind: NotFound, message: "No such file or directory" }'
Common, is generated automatically for you in rust, but it can't when you throw toward Js, so this is where I come in.

Error location :
nice to include if possible. I mostly only test my code once deployed in release mode as a binary though, so don't get your hopes high and instead use a verbose enough expect.

 */

//TODO revisit after having properly learned traits

use js_sys::JsString;
use wasm_bindgen::{JsValue, throw_val,};

//TODO turn into a macro
fn target_is_js () -> bool {cfg!(all(target_arch = "wasm32", not(target_os = "emscripten")))}

mod private {
    use wasm_bindgen::{JsValue};
    //TODO, use a macro to define all the unwrap/expect variants
    pub trait UnwrapJsExt<T> {
        fn unwrap (self) -> T;
        fn expect (self, msg: &str) -> T;
        fn unwrap_js_raw (self) -> T;
        fn expect_js_raw (self, msg : JsValue) -> T;
    }
    pub trait UnwrapJsErrExt<E> {
        fn unwrap_err (self) -> E;
        fn expect_err (self, msg: &str) -> E;
        fn unwrap_js_raw_err (self) -> E;
        fn expect_js_raw_err (self, msg : JsValue) -> E;
    }
}
//TODO, use a macro to define all the unwrap/expect variants
/// An extension trait for `Option<T>` and `Result<T, E>` for unwrapping the `T`
/// value, or throwing the corresponding JS error if it is not available.
/// 
/// # Example TODO
///
/// ```
/// ```
pub trait UnwrapJsExt<T>: private::UnwrapJsExt<T> + Sized {
    /// Unwrap this `Option` or `Result`, but instead of panicking on failure,
    /// throws the corresponding exception to JavaScript.
    #[cfg_attr(debug_assertions, track_caller)]
    fn unwrap_js (self) -> T {
        if target_is_js() {
            self.unwrap_js_raw()
        } else {

            self.unwrap()
        }
    }

    /// Unwrap this `Option` or `Result`, but instead of panicking on failure,
    /// throws an exception to JavaScript.
    /// Serves the exact same purpose as wasm_bindgen::UnwrapThrowExt::expect_throw,
    /// except the message is a JsValue.
    #[cfg_attr(debug_assertions, track_caller)]
    fn expect_js (self, msg : JsValue) -> T {
        if target_is_js() {
            self.expect_js_raw(msg)
        } else {
            self.expect(&msg.as_string().unwrap())
        }
    }
}

//TODO, use a macro to define all the unwrap/expect variants
/// An extension trait for `Option<T>` and `Result<T, E>` for unwrapping the `T`
/// value, or throwing the corresponding JS error if it is not available.
/// 
/// # Example TODO
///
/// ```
/// ```
pub trait UnwrapJsErrExt<E>: private::UnwrapJsErrExt<E> + Sized {
    /// Unwrap this `Result`'s Error, but instead of panicking on Ok case,
    /// throws a JavaScript exception.
    #[cfg_attr(debug_assertions, track_caller)]
    fn unwrap_js_err (self) -> E {
        if target_is_js() {
            self.unwrap_js_raw_err()
        } else {
            self.unwrap_err()
        }
    }

    /// Unwrap this `Result`'s Error, but instead of panicking on Ok case,
    /// throws a JavaScript exception.
    #[cfg_attr(debug_assertions, track_caller)]
    fn expect_js_err (self, msg : JsValue) -> E {
        if target_is_js() {
            self.expect_js_raw_err(msg)
        } else {
            self.expect_err(&msg.as_string().unwrap())
        }
    }
}

//TODO : test this module and add location if relevant
// fn location () -> String {
//     if cfg!(all(debug_assertions, feature = "std")) {
//         let loc = core::panic::Location::caller();
//         std::format!(
//             "{}:{}:{}",
//             loc.file(),
//             loc.line(),
//             loc.column()
//         )
//     } else {
//         "".into()
//     }
// }

impl<T> private::UnwrapJsExt<T> for Option<T> {
    fn unwrap (self) -> T {self.unwrap()}
    fn expect (self, msg: &str) -> T {self.expect(msg)}

    // 'called `Result::unwrap()` on an `Err` value'
    fn unwrap_js_raw (self) -> T {
        self.expect_js_raw("called `Result::unwrap_js()` on a `None` value".into())
    }
    fn expect_js_raw (self, msg : JsValue) -> T {
        match self {
            Some(val) => val,
            None => throw_val(msg),
        }
    }
}
impl<T> UnwrapJsExt<T> for Option<T> {}

impl<T,E> private::UnwrapJsExt<T> for Result<T,E>
where
    E: Into<JsValue>,
    E: core::fmt::Debug,
{
    fn unwrap (self) -> T {self.unwrap()}
    fn expect (self, msg: &str) -> T {self.expect(msg)}

    fn unwrap_js_raw (self) -> T {
        self.expect_js_raw("called `Result::unwrap_js()` on a `Err` value".into())
    }
    fn expect_js_raw (self, msg : JsValue) -> T {
        match self {
            Ok(val) => val,
            Err(e) => throw_val(JsString::from(msg).concat(&": ".into()).concat(&e.into()).into()),
        }
    }
}
impl<T,E> UnwrapJsExt<T> for Result<T,E>
where
    E: Into<JsValue>,
    E: core::fmt::Debug,
{}

impl<T,E> private::UnwrapJsErrExt<E> for Result<T,E>
where
    T: Into<JsValue>,
    T: core::fmt::Debug,
{
    fn unwrap_err (self) -> E {self.unwrap_err()}
    fn expect_err (self, msg: &str) -> E {self.expect_err(msg)}

    fn unwrap_js_raw_err (self) -> E {
        self.expect_js_raw_err("called `Result::unwrap_js()` on an `Ok` value".into())
    }
    fn expect_js_raw_err (self, msg : JsValue) -> E {
        match self {
            Ok(val) => throw_val(JsString::from(msg).concat(&": ".into()).concat(&val.into()).into()),
            Err(e) => e,
        }
    }
}
impl<T,E> UnwrapJsErrExt<E> for Result<T,E>
where
    T: Into<JsValue>,
    T: core::fmt::Debug,
{}
